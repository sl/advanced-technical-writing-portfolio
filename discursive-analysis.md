# A Discursive Analysis of Why's Poignant Guide to Ruby

Introductions to programming are quite common in the world of Computer Science, however none stand out from the pack quite like Why’s Poignant Guide to Ruby. It was written by famous programmer Why the Lucky Stiff, _why, or for the purposes of this analysis, just Why. Why was known for being one of the most prominent creators in the Ruby community. He created hundreds of tools, libraries, and standalone programs that are still used by Ruby developers today, and he notably did so completely anonymously. Eventually however, his identity was revealed online and in response, he chose to disappear from the internet, taking all of his past works with him. Only archives of his works created by other people still exist today. The arguably most interesting thing that he left behind though was not his code, but rather his love letter to Computer Science in the form of a programming tutorial, Why’s Poignant Guide to Ruby.

Programming tutorials are an incredibly common genre amongst technical documents in Computer Science, however Why’s Poignant Guide is interesting not because it is a good example of a typical programming tutorial, but rather because it goes out of its way to break from every discursive stratagem usually employed by such documents. Where other programming tutorials are dry, information dense, and clear, Why’s Poignant Guide is written in a more poetic than prosaic style, tends to be very information sparse, and makes use of heavy metaphors, sarcasm, humor, and pneumonic devices to explain not just how to program in Ruby, but to communicate the importance of programming, and to convey Why’s love for the subject.

The book begins with a short paragraph that sets the tone for the entire piece: “I’ll be straight with you. I want you to cry. To weep. To whimper sweetly. This book is a **poignant** guide to Ruby. That means code so beautiful that tears are shed. That means gallant tales and somber truths that have you waking up the next morning in the arms of this book. Hugging it tightly to you all the day long. If necessary, fashion a makeshift hip holster for *Why’s (Poignant) Guide to Ruby*, so you can always have this book’s tender companionship.”1(p.2, Gillette) This passage anthropomorphizes the book itself, treating it like a companion to help guide you through the “gallant tales and somber truths,” of programming. By doing so, it immediately forces the reader to reframe the tutorial. Rather than thinking of the book as something to learn from, it forces you to conceptualize the book as a tour guide that you are tasked with learning and exploring with. It even goes so far as to jest that you might keep the book with you at all times “so you can always have [the] book’s tender companionship. By changing the readers idea of the purpose the book serves, it challenges the reader to not just try to learn to program, but also to try to expose the beauty that the passage speaks of.  Why forces you to, as he puts it, learn to “*express* your ideas through a computer. [to] write stories for a machine.”1(p.2, Gillette) Thousands of documents exist that specify how to use Ruby, but few exist to explain it’s beauty, to explain how one can learn a whole new way of problem solving through expression under its constraints. Why’s poignant guide takes this tack, and uses it to carve out a space for such documents in the world of computer science.

This tone is easy to create for the introduction to the book as introductions tend to be entirely written in slightly poetic english anyway, but what makes Why’s guide so clever is how it continues to set that tone throughout the rest of the book. To do so, Why employs two techniques. The first method that Why uses to uphold the explorative tone that he maintains throughout his guide is anthropomorphization. In the previous example, Why anthropomorphized the guide itself to give a sense for the role he wanted it to play, but interestingly, he later choses to anthropomorphize Ruby, the programming language, and does this frequently throughout the guide. By treating Ruby like a character in his story, he can explain the way in which computers interpret the code that we present them, and show how that interpretation differs from the way we humans see things. In doing so,  Why shows that through changing our way of thinking, we can better align our understanding with that of the computer, which starts to reveal Why’s fundamental love of computer science. This is shown particularly clearly in the following passage where Why attempts to explain what “nil”, the value that represents the absence of a value, means in Ruby:

> In Ruby, nil represents an emptiness. It is without value. It isn’t zero. Zero is a number.
> It’s Ruby’s own walking dead, a flatlined keyword. You can’t add to it, it doesn’t evolve. But it’s terribly popular. This skeleton’s smiling in all the pictures.
> ```
> plastic_cup = nil
> ```
> The above plastic_cup is empty. You could argue that the plastic_cup contains something, a nil. The nil represents the emptiness, though, so go ahead and call it empty.
> Some of you who have programmed before will be tempted to say the plastic_cup is undefined. How about let’s not. When you say a variable is undefined, you’re saying that Ruby simply has no recollection of the variable, it doesn’t know the var, it’s absolutely non-existent.
> But Ruby is aware of the plastic_cup. *Ruby can easily look in the plastic_cup*. It’s empty, but not undefined.1 (p.4, Gillette)

Here, Why attempts to relate a purely computational concept to the reader by allowing them to see things from Ruby’s perspective. In most people’s mind, it doesn’t make sense for somethings definition to be a statement that it does not exist. That seems somewhat backwards to us. To a computer however, it’s totally reasonable that every value either exists and has a value, or contains nil, indicating that it has no reasonable value. In order to make a concept that’s perfectly reasonable for a computer reasonable to the reader, Why anthropomorphizes Ruby, giving us an idea of the way that it interprets nil. He explains that if you were to have a plastic cup, nil would represent the contents of the cup, or rather the lack thereof. Nil is simply the computer’s way of describing the absence of something in the same way we say the cup is empty to describe it as having an absence of water. This shift in vantage point is the unique perspective that Why’s guide brings to the table. Rather than trying to explain programming in terms that layman can understand, Why attempts to allow readers to understand the way computers process information. By bringing humans to the playing field of the computer, Why allows newcomers to the discipline the chance to see things through the eyes of those who care deeply about programming. He gives them a glimpse into a world usually locked away behind years of experience.

The second method that Why uses to uphold the explorative tone that he maintains throughout his guide is the use of metaphor and imagery. By relating concepts in Ruby to similar ideas in the real world, Why can tell interesting stories that help ground deeply technical concepts in something new programmers can understand. A great example of this is Why’s explanation of falsey/trutheyness. In programming languages, there is a type of value called a Boolean. A Boolean can only hold the values “true”, and “false”. This comes from the mathematical field of Boolean algebra, and in computer programming, allows you to run some code if a value is true, and not run that code if the value is false. This is how programs can make decisions. In some programming languages like Ruby, if you ask if some value is true and it’s not a boolean value (say it’s a number) it can act like it’s either true, in which case it’s known as a “truthy” value, or it can act like it’s false, in which case it’s known as a “falsey” value. In Ruby, all values are truthy except for nil, and false. To explain this concept, Why paints a picture by stating “**everything in Ruby has a positive charge to it**. This spark flows through strings, numbers, regexps, all of it. Only two keywords wear a shady cloak: nil and false draggin’ us down. You can **test that charge** with an if keyword.”1(p.4, Gillette) Rather than stating facts about the Ruby programming language as most tutorials would do, Why tries to paint a picture in the mind of the reader. By simply visualizing the scene described, the reader can understand the concept described very intuitively. While most tutorials use their Logos and Ethos to persuade their readers, Why pushes that aside, instead attempting to appeal in equal part to Logos and Pathos. Again, this represents a significant change in perspective from most tutorials. In the same way that changing the way one perceives of a problem can change ones appreciation for it, changing the way that you discuss solutions to that problem can change the way your perceive solutions to it. By talking about programming lovingly and with passion, Why gives the reader a sense that the ideas presented aren’t just informative, they are beautiful. It changes the way new programmers think of the solution to a problem from a theorem in a textbook, to an artist's interpretation of a painting. It conveys the sense that while there may be many ways to solve a problem, some of them can be beautiful. Many talented programmers talk about the beauty of well written code, however it is rare that that beauty can be understood by those just learning to program. Through his use of metaphor and imagery, Why allows anyone to understand what it means for code to be beautiful.

Why’s Poignant Guide is notable because it defies all expectations about documents of its type. Because Computer Science is such a young field, in order to stay relevant, everyone in the field needs to be constantly learning new technologies, tools, and techniques. Tutorials are a great way to disseminate information quickly, making them invaluable tools for programmers. Because of this, they are incredibly common, widely published, and easily available. Documents which introduce people to new skills in a concise and clear way are in extremely high demand. I’ve been working in industry in Computer Science since I was about thirteen, and I’ve read more programming tutorials than I can count, but none stand out quite like Why’s Poignant Guide. Where most tutorials have lots of code, Why’s guide has lots of prose; where others have practical examples, Why’s guide has cartoon foxes. While Why’s guide certainly doesn’t reveal anything that one must do to command authority when writing in Computer Science,  it does demonstrate an *alternate* way of doing so. Many would laugh at the idea of a tutorial whose primary purpose is not to convey information but to convey passion, but Why showed that not only is there a place for such documents in the field, but that those works of art can thrive and become far more notable and influential than any normal tutorial could.

## Works Cited

1. Gillette, “Why the Lucky Stiff” Johnathan, “Why's Poignant Guide to Ruby.” Why's Poignant Guide to Ruby, 2005, poignant.guide/book.



